# âœ… **Communication Patterns**


## ğŸ”„ Communication Patterns â€“ **Synchronous (REST/gRPC/GraphQL)**

### ğŸš¦ What is Synchronous Communication?

In **synchronous communication**, the **caller waits** for the **response** before continuing.
Itâ€™s like making a phone call â€” you ask a question and **wait for the answer**.

---

## ğŸ”§ Common Synchronous Communication Methods:

### 1. ğŸŒ **REST (Representational State Transfer)**

* Uses **HTTP** and **JSON**
* Simple and widely used
* Based on **resources** (like `/orders`, `/users`)
* Good for: Public APIs, CRUD operations

âœ… **Pros**:

* Easy to use
* Readable URLs
* Standard HTTP methods (GET, POST, PUT, DELETE)

âŒ **Cons**:

* Over-fetching or under-fetching of data
* No built-in schema validation

---

### 2. âš¡ **gRPC (Google Remote Procedure Call)**

* Uses **HTTP/2** and **Protobuf** (binary format)
* Fast and efficient
* Based on **methods**, not resources
* Good for: Internal microservice-to-microservice communication

âœ… **Pros**:

* Very fast (binary + HTTP/2)
* Strongly typed contracts (Protobuf)
* Bi-directional streaming supported

âŒ **Cons**:

* Harder to debug than REST
* Browser support limited

---

### 3. ğŸ” **GraphQL**

* Query language for APIs
* You **ask for exactly the data you need**
* One endpoint for everything (`/graphql`)
* Good for: Complex UIs and mobile apps

âœ… **Pros**:

* No over-fetching or under-fetching
* Flexible queries
* Strong typing (via schema)

âŒ **Cons**:

* More complex to implement
* Performance tuning can be tricky

### ğŸ§  When to Use Synchronous Communication?

Use when:

* **Immediate response** is required (e.g., UI interactions)
* **Request â†’ Response** pattern fits well
* Services are **closely connected**

Avoid when:

* High load may cause **latency**
* You need **loose coupling or retries** â†’ prefer **asynchronous/event-driven**

## ğŸ” Communication Patterns â€“ **Asynchronous (Message Queues & Events)**

### â³ What is Asynchronous Communication?

In **asynchronous communication**, the sender **does not wait** for a response.
Itâ€™s like **sending a message** or email â€” the receiver can process it **later**, at their own pace.

---

## ğŸ§° Common Asynchronous Communication Methods:

### 1. ğŸ“¬ **Message Queues**

* Services send messages to a **queue**
* Other services pick up messages and process them
* Examples: **Azure Service Bus**, **RabbitMQ**, **Amazon SQS**

âœ… **Good for**:

* Decoupling services
* Load buffering
* Background processing

---

### 2. ğŸ“¢ **Events (Pub/Sub)**

* Services **publish events** to a topic or event bus
* Other services **subscribe** and react to those events
* Examples: **Kafka**, **Azure Event Grid**, **AWS SNS/SQS**

âœ… **Good for**:

* Event-driven systems
* Broadcasting changes to many services (e.g., "OrderPlaced" triggers shipping, email)

---

## ğŸ¯ Benefits of Asynchronous Communication

| Feature                    | Benefit                                            |
| -------------------------- | -------------------------------------------------- |
| ğŸ§© **Loose Coupling**      | Services donâ€™t depend on each otherâ€™s availability |
| ğŸ•’ **Improved Resilience** | Temporary failures donâ€™t break the flow            |
| âš–ï¸ **Scalability**         | Queues handle high load by buffering requests      |
| â±ï¸ **Non-blocking**        | Fast response for sender (fire-and-forget)         |

---

## â— Challenges

* **Eventual consistency**: Responses arenâ€™t immediate
* **Harder to debug**: No direct trace like REST calls
* **Message duplication or loss**: Requires retry and idempotency logic
* **Delivery guarantees**: At-least-once, at-most-once, exactly-once

---

## ğŸ§  When to Use Asynchronous Communication?

Use when:

* Tasks can run in the **background**
* You need **decoupled services**
* Services should **react to events** (e.g., OrderPlaced â†’ SendInvoice)

Avoid when:

* **Immediate feedback** is needed (e.g., form submission UI)
* Too many events make flow hard to track

